<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Assignment 3 Experimental Robotics Lab</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Assignment 3 Experimental Robotics Lab </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md1"></a>
About The Project</h1>
<p>In this assignment it is required to use packages for autonomous navigation in order to make a robot navigate a house composed by 6 rooms. In each room it is located a ball with a specific color; each color is therefore associated to a different room as follow:</p>
<ul>
<li>Blue:Entrance</li>
<li>Red:Closet</li>
<li>Green:Living Room</li>
<li>Yellow:Kitchen</li>
<li>Magenta:Bathroom</li>
<li>Black:Bedroom</li>
</ul>
<p>The robot should then implement four behaviors:</p>
<ul>
<li>Normal</li>
<li>Sleep</li>
<li>Play</li>
<li>Find</li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
Architecture and parameters</h1>
<p>In order to build the map of the house and make the robot navigate around it properly(avoiding abstacles) I used the Gmapping filtering-based approach and the MoveBase package which is part of the ROS Navigation stack. The MoveBase package has the final purpose to make a robot navigate an environment using both a local and global path planner that can be selected by the user. The MobeBase relies on a map that can be known a-priori or can be built during the execution(our case). Since the MoveBase implements an action server, inside the folder src of the exp-Assignment3 package I implemented the action client 'simple_navigation_goals', responsible for sending goals to the action server and therefore move the robot to the correct position. The goals generated by the action client are expressed with respect to the frame of the map, and not the frame of the robot. The explore-lite package is used together with MoveBase and Gmapping to automatically explore the map when required. In order to enable and disable the functioning of the package during the code execution, I used </p><div class="fragment"><div class="line">$ self.child = subprocess.Popen([&quot;roslaunch&quot;,&quot;explore_lite&quot;,&quot;explore.launch&quot;])</div>
<div class="line">$ self.child.send_signal(signal.SIGINT)</div>
</div><!-- fragment --><p> This was necessary because the motion of the robot had to rely on that package only during the Find state.</p>
<p>Inside the folder script of the same package I implemented the state machine '<a class="el" href="state__machine_8py.html">state_machine.py</a>', that leads the whole process. This node communicates with the action client publishing target positions expressed as a list of integers(as shown inside the msg folder). <br  />
</p>
<p>The state machine makes use of some data: inside the workspace the file 'param.yaml' can be found, which contains default data that will be stored in the parameter server once the program is executed.</p>
<p>In the first 6 lines we can find parameters to associate each room with a color. If we consider the first line:</p>
<p>Closet: [-5.41, 2.48, 'F', red_ball]</p>
<p>I described each room with a list of arguments, the first two indicates the (x,y) reference coordinates of the room(extracted using Rviz), the third indicates if the room has already been discovered by the robot, while the last simply associate the room to a ball as required.</p>
<p>With the following line I simly created a list with the rooms of the apartment</p>
<p>rooms: ['red_ball', 'green_ball', 'blue_ball', 'black_ball', 'magenta_ball', 'yellow_ball']</p>
<p>In the end, I stored some default position</p>
<p>playPose: [-5, 8] homePose: [-2.86, -2.95]</p>
<p>Inside the state machine are implemented the four abovementioned states:</p>
<ul>
<li>Normal State: relying on the MoveBase packages, the robot moves randomly around the house; in particular, a new target is sent everytime the robot stops moving. While moving the robot may detect a new colored object in the house. When this happens, the robot switches to the function Track. In this function the robot, after getting closer to the detected object, updates the parameter server marking as discovered the corresponding room(the third parameter in the list of the room is set to 'T'). After some time, the robot switches to the play or sleep state.</li>
<li>Sleep State: the robot goes to a predifined location(taken from the parameter server) and stays there for a certain time. After that goes back to Normal behaviour.</li>
<li>Play State: the robot goes to the play pose(taken from the parameter server) waiting for a goTo command. The goTo command is simulated extracting randomly from the parameter 'rooms' in the parameter server. The robot checks if the extracted room has already been discovered. If so, goes there using the (x,y) coordinates stored in the parameter server. After this it goes back to the play pose waiting for another goTo command. On the contraty, if the room has not been discovered yet, it switches to the Find state passing as parameter the color of the ball in that room.</li>
<li>Find state: the robot starts moving around the house relying on the explore-lite package. When it detects a new ball it switches to the Track function that works as in the normal state. Then the robot checks if the ball in the just detected room coincide with the ball received by the Play state. If so, it goes back to the play behaviour; if not, keeps moving around the house. After some time, if the robot has not detected the received room, goes back to the play behaviour.</li>
</ul>
<p>In each state I used lots of 'loginfo' functions in order to be able to follow the state machine behaviour and check that everyting is working properly.</p>
<p>Below the state machine and architecture diagrams.</p>
<p><img src="https://github.com/CristinaNRR/final_exp/blob/master/Images/state_machine_diagram.png" alt=" " width="600" height="400" class="inline"/> <em>Figure 1 : state machine diagram</em></p>
<p><img src="https://github.com/CristinaNRR/final_exp/blob/master/Images/Architecture_diagram.png" alt=" " width="600" height="400" class="inline"/> <em>Figure 2 : software architecture</em></p>
<h1><a class="anchor" id="autotoc_md3"></a>
Packages and file list</h1>
<p>Inside the workspace we can find the following packages:</p><ul>
<li><a class="el" href="namespaceexp__assignment3.html">exp_assignment3</a>: contains the state machine inside the folder script, the simple_navigation_goals action client inside the folder src, the launch file simulation.launch inside the folder launch(which is used to launch the whole simulation, opening both Gazebo and Rviz).</li>
<li>planning: contains the gmapping.launch and the the move_base.launch files inside the launch folder.</li>
<li>gmapping: contains the description of the robot inside the urdf folder and the code used by the gmapping algorithm.</li>
<li>explore: contains the explore.launch file that activates the explore-lite package. Inside the doxygen folder we can find the code documentation of the project.</li>
</ul>
<h1><a class="anchor" id="autotoc_md4"></a>
Installation and running procedure</h1>
<ul>
<li>clone the repository inside home <div class="fragment"><div class="line">$ git clone https://github.com/CristinaNRR/final_exp.git</div>
</div><!-- fragment --></li>
<li>build and source the workspace <div class="fragment"><div class="line">$ cd final_exp</div>
<div class="line">$ catkin_make</div>
<div class="line">$ source devel/setup.bash</div>
</div><!-- fragment --></li>
<li>launch the simulation and store the parameter in the parameter server <div class="fragment"><div class="line">$ roslaunch exp_assignment3 simulation.launch </div>
<div class="line">$ rosparam load param.yaml</div>
</div><!-- fragment --></li>
</ul>
<p>Looking at the terminal we can follow all the steps performed by the state machine including its change of states.</p>
<h1><a class="anchor" id="autotoc_md5"></a>
System features and possible tecnical improvements</h1>
<p>To test and correct the robot behaviour I added print functions in the code. This is also useful in order to follow the robot behavior during the program execution. During the whole execution I decided to publish new target positions to the moveBase action client everytime the robot stops moving. This is the easiest solution I found to be sure that the state machine is 'syncronized' with the motion of the robot. While the robot is moving to some position guided by the moveBase package it may happen that it detects a colored ball in the environment: the robot will now start moving towards the ball simply publishing new commands on the cmd_vel topic. The robot will stop tracking the ball when the velocity published on cmd_vel is almost 0 or a predefined number of iteration has been reached(this last option was needed because sometimes it happens that the robot is not able to actually reach the ball because it gets stuck in some wall). Once the robot stops tracking the ball, it will continue following its previous goal relying again on the commands published by moveBase.</p>
<p>Some possible improvements:</p><ul>
<li>Handle the fact that sometimes the robot is required to move to a position which is outside the walls of the house.</li>
<li>In order to execute the transition between normal and play state I simply introduced a counter in the normal state. Once the counter reaches a predefined value the system switches to the play state. One improvement might be to receive the play command from a stand alone node.</li>
<li>As said before, the reference positions of each room, have been stored manually before the execution inside the parameter server. However, the positions will be unknown to the robot until it actually explore the rooms; only in that moment the reference positions will be marked as 'T' and therefore the robot will be able to use them. One improvement might be to obtain the positions at runtime once the robot gets close to the ball.</li>
</ul>
<p>Regarding the last point, I decided to store myself the reference positions of the rooms because, as said before, I noticed that in some rare case when the robot detects a new ball it is not always able to actually gets close to it since it may get stuck in some walls between its position and the ball. This of course may happen since in the ball tracking the robot is not relying on the moveBase package to guide its motion.</p>
<h1><a class="anchor" id="autotoc_md6"></a>
Author and contacts</h1>
<p>Cristina Naso Rappis mail: <a href="#" onclick="location.href='mai'+'lto:'+'cri'+'.t'+'enn'+'is'+'97@'+'gm'+'ail'+'.c'+'om'; return false;">cri.t<span style="display: none;">.nosp@m.</span>enni<span style="display: none;">.nosp@m.</span>s97@g<span style="display: none;">.nosp@m.</span>mail<span style="display: none;">.nosp@m.</span>.com</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.0
</small></address>
</body>
</html>
